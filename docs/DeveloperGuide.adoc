= A.T.A.S (Amazing Task and Assignment System) Developer Guide
:site-section: UserGuide
:toc:
:toclevels: 4
:toc-title: Contents
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]

By: `Team M16-1` Since: `Jan 2020` License: `MIT`

== Design
This section will give a high-level overview of how various components in ATAS function and interact with each other.

=== Architecture
The following sections will explain each component in greater detail.

=== Atas Component
The sequence diagram below shows how various components in the Atas class interact when the user enters a `help` command
image::Atas help command sequence diagram v2.PNG[Component interactions for help command]

The Atas Class contains the main logic for ATAS. +
1. Atas uses the UI class to read user input. +
2. The Parser class is used to parse the user input string, returning a Command object. +
3. The Command's execute() method is run, returning a CommandResult object. +
4. Atas then uses the UI class to show the CommandResult's message to the user. +
5. Finally, Atas uses the Storage object to save the new state of the application.


=== UI Component

=== Parser Component
image::parser class diagram v1.PNG[Parser Class Diagram]
1. The Atas class uses the Parser class' static parseCommand() method to parse user commands. +
2. The Parser class' parseCommand() method then returns the appropriate Command object depending on the user input.

=== Storage Component
image::storage.PNG[Storage Class Diagram]
1. A Storage object is created by the Atas class to handle the loading and saving of task data.
2. The load() method is used to read saved data from a local file into the current session of ATAS.
3. The save() method writes the current state of ATAS into the local save file using the Task.encodeTask() method.

=== Command Component

=== CommandResult Component

== Implementation
This section will detail how some noteworthy features are implemented.

=== Delete Command
image::delete.png[Delete Command sequence diagram]

*Step 1.* +
The Parser Class will call `prepareDeleteCommand` method and processes the delete index once it detects a `delete` command.

[WARNING]
If an `IndexOutOfBoundsException` or `NumberFormatException is detected`, the Parser class will create a new `IncorrectCommand` class
to display the corresponding error messages

*Step 2.* +
`prepareDeleteCommand` will create a new `DeleteCommand` class.

[WARNING]
If there is no items in the task list, the `DeleteCommand` class will create a new `IncorrectCommand` class to display the
corresponding error message

*Step 3.* +
`DeleteCommand` class will call the `TaskList` class to get the updated task list and deletes the task corresponding to the index.

=== Search Command
*Step 1.* +
The Parser Class will call `prepareDeleteCommand` method and process the `task type` and `search query`

[NOTE]
`task type` refers to `all`,`event' or `assignment`

*Step 2.* +
`prepareSearchCommand method` will create a new `SearchCommand` class

*Step 3.* +
`SearchCommand` class will check the `task type` and calls their respective methods. In each of the respective methods, an ArrayList is used
to store the original index of the results.

* If `task type` is *all*, `SearchCommand` class will call the `getSearchQueryAllTasks` method and returns an ArrayList of the results.

* if `task type` is *event*, `SearchCommand` class will call the `getSearchQueryEvents` method and returns an ArrayList of the results.
* if `task type` is *assignment*, `SearchCommand` class will call the `getSearchQueryAssignments` and returns an ArrayList of all the results.

*Step 4.* +
`SearchCommand` class calls the `searchList` method to format the results of the search query into a String format

*Step 5.* +
`SearchCommand` class calls the `resultsList` method to print the results of the search query, and creates a new `IncorrectCommand`
class to print the success message


[WARNING]
if there are no results to the search query or if there are no tasks in the task list, `SearchCommand` class
will create a new `IncorrectCommand` class to print the error messages


=== Repeat event feature
==== Current Implementation
* The `RepeatCommand` class extends `Command` class and initializes 3 values within a specified `Event` object which are stated below.
This will flag the given event as repeating, allowing other features to be able to catch and perform relevant desired behaviours.
. `Boolean isRepeat` variable: Set to true, marking the event as a repeating event.
. `int numOfPeriod` variable: Set to the given value that states the frequency which typeOfPeriod will repeat at.
. `String typeOfPeriod` variable: Set to d (days), w (weeks), m (months) or y (years) to indicate how often it will repeat.

* Given below is an example usage scenario and how the repeat command mechanism behaves at each step.
. The user launches the app and retrieves the tasks which are saved under a local file using Storage.
. He/She enters `repeat id/2 p/1w` into the command line. Method `parseCommand()` from `Parser` will be called to parse the command
provided. It will obtain the information to get integers `eventID`, `numOfPeriod` and also String `typeOfPeriod`.
. A new instance of RepeatCommand with `eventID`, `numOfPeriod` and `typeOfPeriod` initialized will be created. The `execute` method of
`repeatCommand` will then be called.
. `execute` command will do 3 things after it calls `getTask` method from `TaskList` class to get the user input task.
** It will check if the `eventID` provided refers to a valid `Event` task.
** It will then check if `numOfPeriod` equals to 0. In which case, it will be setting the event to not repeat by calling `setNoRepeat`
method from `Event` class.
*** `setNoRepeat` method will reinitialize the 3 variables (`isRepeat`, `numOfPeriod`, `typeOfPeriod`) to `false`, `0` and `null` respectively.
** If it is not 0, it will set the event to repeating by calling `setRepeat` method from `Event` class.
*** `setRepeat` method will initialize the 3 variables (`isRepeat`, `numOfPeriod`, `typeOfPeriod`) to the respective values given by
user. In this example, they will be set to `true`, `1` and `w` respectively.
. After `execute` command is done, it will return a new `ResultCommand` class with a string containing the result of the execution.
This string will be printed by calling `showToUser` method in the `Ui` class. Then the event will be saved into local file by calling
`trySaveTaskList` method from `Storage` class.

* The following sequence diagram summarizes how repeat command operation works: +

image::RepeatCommand_UML.png[Repeat Command Sequence Diagram]

==== Impact on Event dates
* With the implementation in mind, every time the app is launched, after `load` method in `Storage` class is called, the app will call a
method `updateEventDate` which will iterate through every task in the list  and calls `updateDate` method from `Event` class if the task
is a repeating event and its date is in the past.

==== Design Considerations
* Allowing only tasks that are `Event` to be repeated
** Rationale: +
We feel that given the context of University Students, it makes little sense for most assignments to repeat. However, it makes sense for
 events to repeat since many events actually occur on a regular basis.
** Alternative considered: +
. Allowing all tasks to be repeatable.
*** Pros: Allow more flexibility for the user to set which tasks they want to repeat, regardless of task type.
*** Cons: Memory wastage as additional variables are set for repeating tasks and in the case of minimal assignments requiring to be
repeated, these spaces are wasted.

* Allowing event to repeat for any amount of period by using `numOfPeriod` and `typeOfPeriod` (d, w, m ,y)
** Rationale: +
It provides great flexibility in allowing an event to repeat for any specified frequency. For example, some classes occur every 2 weeks.
Some events may happen every 10 days or any x amount of period.
** Alternative considered:
. Removing `numOfPeriod` and fixing it to just 4 types of recurrence.
*** Pros: It would simply usability and implementation since there will only be 4 options to choose from.
*** Cons: It would reduce the usability for the 2 examples provided above as users would not be able to make events repeat every 2 weeks
or 10 days, forcing them to have to manually type in the same event for as many times as it will occur if they wish to still keep track
of that event.

* Keeping repeated event as a single entity within the list and not repeatedly add new events of a newer date when repeat command is used.
** Rationale: +
It allows the repeated events to be removed or to stop repeating with ease as it remains a single entity and not multiple events,
improving the user's usability.
** Alternative considered:
. Repeatedly add new events with changes in dates for a fixed amount when repeat command is used.
*** Pros: It will be simpler to implement and test if repeating events can be treated like any other events as coupling is lower.
*** Cons: Deleting a repeating event would be difficult as there would be multiple entries to delete. It will also flood the tasklist of
the user and increase the file size of the local storage that stores the tasklist.

=== Calendar feature